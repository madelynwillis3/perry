---
title: "Perry_analysis"
author: "Madelyn Willis"
date: "`r Sys.Date()`"
output: html_document
---

##Unloading Necessary Packages
```{r Packages, include=FALSE}
#chunk options
knitr::opts_chunk$set(echo = TRUE)

    #libraries
#library(reticulate)
#library(rgee)
#ee_Authenticate()
#ee_Initialize()
library(sf)
library(tidyverse)
library(raster)
library(terra)
library(ggplot2)
library(viridis)
library(corrr)
library(rstac)
library(ggcorrplot)
library(GGally)
library(randomForest)
library(sf)
library(sp)
library(gstat)
library(raster)
library(automap)
```


##Pulling Data/Imagery
```{r AOI}
#FYI: USING WGS 84 as it is what GEE uses.

#Grabbing geojson border shapefile:
border <- st_read("Data/Border/Border_json.geojson")
#aoi <- sf_as_ee(border) #open back up when on laptop

```

```{r Soil Samples}
#NOTE: I am currently using the AESL samples taken in 2024, all composite samples taken at a 4 acre grid scale.

#Grabbing Sample ID's
soil_points <- st_read("Data/Samples/Composite_Odds_17N.shp")


#CSV of AESL data:
soil_C_4ac <- read.csv("Data/Samples/Perry_Composite_4ac.csv")

# Merge points + sample data:
soil_points <- merge(soil_points, soil_C_4ac, by = "CID") #CID is Composite ID, since we only have composite data back so far.


```


```{r LANDSAT}
#GEE:

#filtering geojson by AOI:
#image_collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
#  filterBounds(aoi)

#grabbing bands from LANDSAT8: 
#image_banding <- image_collection$select(c('B2', 'B3', 'B4', 'B5', 'B6', 'B7'))

```

```{r Bare Soil}
#planet bare soil imagery: 
bare_soil <- rast("Data/Planet/Bare Soil Imagery/Apr 2022/20220429_152053_57_245c_3B_udm2_clip_projected.tif")
bare_soil_wgs84 <- project(bare_soil, "EPSG:4326", res = 1, method = "bilinear") #doesn't work
bare_soil_res1 <- resample(bare_soil, USGS_DEM)


# SURFACE REFLECTANCE:

reflectanceCoefficients <- c(2.028e-05, 1.959e-05, 2.094e-05, 2.124e-05,  # Bands 1-4 
                             2.018e-05, 1.511e-05, 1.372e-05, 1.092e-05)  # Bands 5-8 

# Apply band-specific reflectance coefficients (not sure if Planet already corrected for SR)
surface_reflectance <- bare_soil
for (i in 1:nlyr(bare_soil)) { #for every band, multiply value by its band coefficient
  surface_reflectance[[i]] <- bare_soil[[i]] * reflectanceCoefficients[i]
}

# Save new SR
writeRaster(surface_reflectance, "Output/Bare_soil/SR.tif", overwrite = TRUE)

  # Plot random band:
plot(surface_reflectance[[7]], main = "NIR1 Surface Reflectance")
plot(bare_soil[[7]])

```

```{r NDVI}

# Veg data: Planet 
Vegstack <- rast("Data/Planet/Veg Imagery/Sept 2022/20220921_152148_44_2465_3B_AnalyticMS_SR_8b_clip.tif")
Vegstack_wgs84 <- project(Vegstack, "EPSG:4326", method = "bilinear")

#NDVI:


NIR <- Vegstack_wgs84[[8]]  # NIR band
Red <- Vegstack_wgs84[[6]]  # Red band

# formula
NDVI <- (NIR - Red) / (NIR + Red)

# Plot NDVI
plot(NDVI)


#SAVI: 


L <- 0.5  # adjustable

# formula
SAVI <- ((NIR - Red) / (NIR + Red + L)) * (1 + L)

# Plot SAVI
plot(SAVI)

```


```{r 1m DEM}

# Load the USGS 1m DEM (acts as the template)
USGS_DEM <- rast("Data/USGS DEM/DEM rasters/output_USGS1m.tif")

# border:
border <- vect("Data/Border/border_17N.shp")

# Crop and mask the DEM to the border extent
clipped_DEM <- crop(USGS_DEM, border) |> mask(border)

# Load all topographic rasters
topo_files <- list.files("Data/all rasters/", full.names = TRUE)
topo_rasters <- lapply(topo_files, rast)

# Function to align rasters (clip first, then resample to 1m)
align_raster <- function(r, template, border) {
  # Reproject raster
  if (crs(r) != crs(template)) {
    r <- project(r, crs(template), method = "bilinear")
  }
  # Resample to match the clipped DEM's resolution
  r <- resample(r, template, method = "bilinear")
  # Crop and mask to the border FIRST
  r <- crop(r, border) |> mask(border)

  return(r)
}

# Align all rasters
aligned_rasters <- lapply(topo_rasters, align_raster, template = clipped_DEM, border = border)

# Stack aligned rasters
clipped_stack <- rast(aligned_rasters)

# Summary check
summary(clipped_stack)


```


```{r 1m rasters, eval = FALSE}

#Visualizations via OpenTopography:
aspect <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_aspect.tif")
#aspect_wgs84 <- project(aspect, "EPSG:4326",res = 1, method = "bilinear")
clipped_aspect <- mask(aspect, vect(border))
plot(clipped_aspect)

color_relief <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_color-relief.tif")
color_relief_wgs84 <- project(color_relief, "EPSG:4326",res = 1, method = "bilinear")
clipped_color_relief_wgs84 <- mask(color_relief_wgs84, vect(border))

color_hillshade <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_hillshade-color.tif")
color_hillshade_wgs84 <- project(color_hillshade, "EPSG:4326",res = 1, method = "bilinear")
clipped_color_hillshade_wgs84 <- mask(color_hillshade_wgs84, vect(border))

hillshade <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_hillshade.tif")
hillshade_wgs84 <- project(hillshade, "EPSG:4326",res = 1, method = "bilinear")
clipped_hillshade_wgs84 <- mask(hillshade_wgs84, vect(border))

roughness <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_roughness.tif")
roughness_wgs84 <- project(roughness, "EPSG:4326",res = 1, method = "bilinear")
clipped_roughness_wgs84 <- mask(roughness_wgs84, vect(border))

slope <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_slope.tif")
slope_wgs84 <- project(slope, "EPSG:4326",res = 1, method = "bilinear")
clipped_slope_wgs84 <- mask(slope_wgs84, vect(border))


#SAGA visualizations:
slope_height <-rast("Data/USGS DEM/SAGA/Slope Height.sg-grd-z")
slope_height_wgs84 <- project(slope_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_slope_height_wgs84 <- mask(slope_height_wgs84, vect(border))

valley_depth <-rast("Data/USGS DEM/SAGA/Valley Depth.sg-grd-z")
valley_depth_wgs84 <- project(valley_depth, "EPSG:4326",res = 1, method = "bilinear")
clipped_valley_depth_wgs84 <- mask(valley_depth_wgs84, vect(border))

norm_height <-rast("Data/USGS DEM/SAGA/Normalized Height.sg-grd-z")
norm_height_wgs84 <- project(norm_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_norm_height_wgs84 <- mask(norm_height_wgs84, vect(border))

std_height <-rast("Data/USGS DEM/SAGA/Standardized Height.sg-grd-z")
std_height_wgs84 <- project(std_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_std_height_wgs84 <- mask(std_height_wgs84, vect(border))

mid_slope_pos <-rast("Data/USGS DEM/SAGA/Mid-Slope Positon.sg-grd-z")
mid_slope_pos_wgs84 <- project(mid_slope_pos, "EPSG:4326",res = 1, method = "bilinear")
clipped_mid_slope_pos_wgs84 <- mask(mid_slope_pos_wgs84, vect(border))

topo_pos_index <-rast("Data/USGS DEM/SAGA/Topographic Position Index.sg-grd-z")
topo_pos_index_wgs84 <- project(topo_pos_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_topo_pos_index_wgs84 <- mask(topo_pos_index_wgs84, vect(border))

topo_wet_index <-rast("Data/USGS DEM/SAGA/Topographic Wetness Index.sg-grd-z")
topo_wet_index_wgs84 <- project(topo_wet_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_topo_wet_index_wgs84 <- mask(topo_wet_index_wgs84, vect(border))

terr_rugged_index <-rast("Data/USGS DEM/SAGA/Terrain Ruggedness Index (TRI).sg-grd-z")
terr_rugged_index_wgs84 <- project(terr_rugged_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_terr_rugged_index_wgs84 <- mask(terr_rugged_index_wgs84, vect(border))

mrvbf <-rast("Data/USGS DEM/SAGA/MRVBF.sg-grd-z")
mrvbf_wgs84 <- project(mrvbf, "EPSG:4326",res = 1, method = "bilinear")
clipped_mrvbf_wgs84 <- mask(mrvbf_wgs84, vect(border))

mrrtf <-rast("Data/USGS DEM/SAGA/MRRTF.sg-grd-z")
mrrtf_wgs84 <- project(mrrtf, "EPSG:4326",res = 1, method = "bilinear")
clipped_mrrtf_wgs84 <- mask(mrrtf_wgs84, vect(border))


```




##Data Wrangling



```{r Rescaling Planet Data, eval = FALSE} 
#NOT WORKING :(

#ALL PLANET DATA MUST BE RESCALED TO MATCH DEM (1m) DATA
    #I will be using USGS_DEM_wgs84 for this

#Bare_soil:

bare_soil_1m <- resample(rast("Data/Planet/Bare Soil Imagery/Apr 2022/20220429_152053_57_245c_3B_udm2_clip_projected.tif"), USGS_DEM_wgs84, method = "bilinear")

#SR:

surface_reflectance_1m <- resample(surface_reflectance, USGS_DEM_wgs84, method = "bilinear")

#NDVI:

NDVI_1m <- resample(NDVI, USGS_DEM_wgs84, method = "bilinear")


#Other planet data:

  #SAVI:
SAVI_1m <- resample(SAVI, USGS_DEM_wgs84, method = "bilinear")


#confirm with res()
```

```{r Clipping Dataset, eval = FALSE }


#Bare soil
clipped_bare_soil <- mask(bare_soil, vect(border))

#SR
clipped_SR <- mask(surface_reflectance_1m, vect(border))




```

```{r SNAP}

# Convert soil points to raster
soil_raster <- rasterize(vect(soil_points), topo_rasters[[1]], field = 1)
soil_raster_clipped <- crop(soil_raster, border, mask = TRUE)

# snap func
snap_to_soil <- function(r) {
  resample(r, soil_raster_clipped , method = "bilinear")
}

# Apply snapping to all pre-aligned rasters?
snapped_rasters <- lapply(aligned_rasters, snap_to_soil)

# Convert back to stack
snapped_stack <- rast(snapped_rasters)

```

```{r Data Snapping, eval = FALSE }

# vect the sample data
soil_points_vect <- vect(soil_points)

# Snap the points to the raster: (confirming each point is within the raster grid)
snapped_points <- terra::extract(clipped_aspect_wgs84, soil_points_vect, method = "bilinear", small = TRUE)

# Combine snapped points with their corresponding properties
soil_points$snapped_value <- snapped_points


# Convert the raster to a data frame
raster_df <- as.data.frame(clipped_aspect_wgs84, xy = TRUE, na.rm = TRUE)

#name column layer
colnames(raster_df)[3] <- "layer"  

# Plot 
ggplot() +
  # Raster layer
  geom_raster(data = raster_df, aes(x = x, y = y, fill = layer)) +
  scale_fill_viridis_c() + #color friendly 
  # Soil points layer
  geom_sf(data = soil_points, aes(color = "red"), size = 2) + 
  theme_minimal() +
  theme(legend.position = "none")





```




```{r Organizing}
# Extract raster values at soil sample points
extracted_raster_values <- extract(snapped_stack, soil_points, xy = FALSE)

# Convert to a data frame
raster_df <- as.data.frame(extracted_raster_values)


soil_df <- soil_points %>%
  st_drop_geometry() %>%
  as.data.frame()  # Convert to a plain data frame

# Select only the desired columns explicitly using base R
soil_df <- soil_df[, c('LBC.1', 'LBCeq', 'pH.2', 'Ca', 'K', 'Mg', 'Mn', 'P', 'Zn')]

# Merge extracted raster values with soil data
combined_df <- cbind(soil_df, raster_df)
```



##Correlation Matrix
```{r Cor() }
# Compute correlation matrix
cor_matrix <- cor(combined_df, use = "pairwise.complete.obs", method = "spearman")

```

```{r plotting CM }
#formatting:
ggcorrplot(cor_matrix, type = "lower", 
           lab = TRUE, show.legend = TRUE, 
           tl.cex = 4, # Adjust text size
           lab_size = 2, # Adjust correlation label size
           tl.srt = 45) # Rotate axis labels

ggcorrplot(cor_matrix, type = "lower", 
           lab = TRUE, show.legend = TRUE, 
           tl.cex = 4, # Adjust text size
           lab_size = 2, # Adjust correlation label size
           tl.srt = 45,           
           hc.order = TRUE, # Cluster similar variables together
           insig = "blank", # Hide insignificant correlations
           p.mat = cor_pmat(combined_df)
           ) # Rotate axis labels


# col name of soil properties
soil_vars <- colnames(soil_df)
# topo name list
topo_vars <- setdiff(colnames(combined_df), soil_vars)

# Compute correlation matrix only between soil properties and topo rasters
cor_matrix_soil_topo <- cor(combined_df[, soil_vars], combined_df[, topo_vars], 
                            use = "pairwise.complete.obs", method = "spearman")

# Visualize
ggcorrplot(cor_matrix_soil_topo, lab = TRUE, show.legend = TRUE, 
           tl.cex = 5, lab_size = 2, tl.srt = 45, method = "circle")




#scatterplot



```

```{r corr buffer test, eval=FALSE, include=FALSE}
# Step 1: Create a buffer around soil points
buffer_distance_m <- 104.35 * 0.3048  # Convert feet to meters
soil_buffers <- st_buffer(soil_points, dist = buffer_distance_m)

# Step 2: Extract raster values from the buffers
extracted_raster_values_buffer <- extract(snapped_stack, soil_buffers, xy = FALSE)

# Convert to a data frame
raster_df_buffer <- as.data.frame(extracted_raster_values_buffer)

# Step 3: Select relevant soil data columns
soil_df <- soil_points %>%
  st_drop_geometry() %>%
  as.data.frame()  # Convert to a plain data frame

# Select only the desired columns explicitly using base R
soil_df <- soil_df[, c('LBC.1', 'LBCeq', 'pH.2', 'Ca', 'K', 'Mg', 'Mn', 'P', 'Zn')]

# Merge extracted raster values with soil data
combined_df_buffer <- cbind(soil_df, raster_df_buffer)

# Step 4: Compute the correlation matrix
cor_matrix_buffer <- cor(combined_df_buffer, use = "pairwise.complete.obs", method = "spearman")

# Print the correlation matrix
print(cor_matrix_buffer)

# Optionally, visualize correlations with a heatmap
library(ggcorrplot)
ggcorrplot(cor_matrix_buffer, type = "lower", lab = TRUE, show.legend = TRUE)

```




#Stack Results
```{r Stack data }
#select correlated rasters and soil properties:

# Function to extract top correlated rasters
get_top_correlated <- function(soil_vars, cor_matrix, n = 3) {
  top_vars <- names(sort(abs(cor_matrix[soil_var, ]), decreasing = TRUE)[1:n])
  return(top_vars)
}
```

#Kriging
```{r PA method}
# Create variogram model for each variable
fit_variogram_model <- function(variable) {
    # Create the formula
    var_name <- as.formula(paste(variable, "~ 1"))
    
    # Calculate the variogram
    vgm_data <- variogram(var_name, data = soil_points)
    
    # Fit the variogram model
    vgm_model <- fit.variogram(vgm_data, model = vgm("Gau", psill = 1, range = 300, nugget = 0))
    
    # Return the fitted model
    return(list(variable = variable, vgm_data = vgm_data, vgm_model = vgm_model))
}

# Fit variogram models for each variable
variogram_models <- lapply(soil_vars, fit_variogram_model)


# Create a function to perform kriging for each variable
perform_kriging <- function(variable, vgm_model) {
    # Create a prediction grid
    grid <- st_as_sf(st_make_grid(soil_points, cellsize = 10), crs = st_crs(soil_points))
    
    # Perform kriging
    kriging_result <- krige(formula = as.formula(paste(variable, "~ 1")),
                             locations = soil_points,
                             newdata = grid,
                             model = vgm_model)
    
    # Return the kriging result
    return(kriging_result)
}

# Perform kriging for each variable using the fitted variogram models
kriging_results <- lapply(variogram_models, function(model) {
    perform_kriging(model$variable, model$vgm_model)
})

```

#RF
```{r DSM method}

```
#Classification
```{r Classification}


#K
classify_K <- function(K) {
  case_when(
    K <= 60  ~ "Low K (0-60 lbs/A)",    
    K <= 150 ~ "Medium K (61-150 lbs/A)",  
    K <= 250 ~ "High K (151-250 lbs/A)",  
    K > 250  ~ "Very High K (250+ lbs/A)"
  )
}
#P
classify_P <- function(P) {
  case_when(
    P <= 30  ~ "Low P (0-30 lbs/A)",
    P <= 60  ~ "Medium P (31-60 lbs/A)",
    P <= 100 ~ "High P (61-100 lbs/A)",
    P > 100  ~ "Very High P (100+ lbs/A)"
  )
}

#pH
classify_pH <- function(pH, LBC) {
  lime_table <- read.csv("lime_requirements.csv")  # Make sure this table is structured properly
  required_lime <- lime_table %>%
    filter(pH == round(pH, 1)) %>%
    select(as.character(LBC)) %>%
    pull()

  return(required_lime)
}


#Mg
classify_Mg <- function(Mg) {
  case_when(
    Mg <= 30  ~ "Low Mg - Apply Dolomitic Lime",
    Mg <= 60  ~ "Medium Mg - No Extra Mg Needed",
    Mg > 60   ~ "High Mg - No Supplement Needed"
  )
}
#Zn
classify_Zn <- function(Zn) {
  if (Zn < 3) {
    return("Apply 3 lbs Zn/Acre")
  } else {
    return("No Zn Needed")
  }
}

```
#Condense
```{r Flatten Stacks}

```
#Clean Maps
```{r Clean Up Maps}

```

```{r Compare Maps}

```





```{r pH: extra stuff}

# Convert sf to sp
soil_points_sp <- as(soil_points, "Spatial")

# Compute the empirical variogram for pH
emp_variogram <- variogram(soil_points_sp$pH.2 ~ 1, soil_points_sp)

# Fit a model to the variogram
var_model <- fit.variogram(emp_variogram, vgm(c("Sph", "Exp", "Gau")))

# Plot the variogram
plot(emp_variogram, model = var_model)

```



