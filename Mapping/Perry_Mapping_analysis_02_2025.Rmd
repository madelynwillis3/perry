---
title: "Perry_analysis"
author: "Madelyn Willis"
date: "`r Sys.Date()`"
output: html_document
---

##Unloading Necessary Packages
```{r Packages, include=FALSE}
#chunk options
knitr::opts_chunk$set(echo = TRUE)

    #libraries
#library(reticulate)
#library(rgee)
#ee_Authenticate()
#ee_Initialize()
library(sf)
library(tidyverse)
library(raster)
library(terra)
library(ggplot2)
library(viridis)
library(corrr)
library(rstac)
library(ggcorrplot)
library(GGally)
library(randomForest)
library(sf)
library(sp)
library(gstat)
library(raster)
library(automap)
library(tmap)
```


##Pulling Data/Imagery


```{r Soil Samples}
#NOTE: I am currently using the AESL samples taken in 2024, all composite samples taken at a 4 acre grid scale.

#Grabbing Sample ID's
soil_points <- st_read("Data/Samples/Composite_Odds_17N.shp")


#CSV of AESL data:
soil_C_4ac <- read.csv("Data/Samples/Perry_Composite_4ac.csv")

# Merge points + sample data:
soil_points <- merge(soil_points, soil_C_4ac, by = "CID") #CID is Composite ID, since we only have composite data back so far.


```






```{r 1m DEM}

# Load the USGS 1m DEM (acts as the template)
USGS_DEM <- rast("Data/USGS DEM/DEM rasters/output_USGS1m.tif")

# border:
border <- vect("Data/Border/border_17N.shp")

# Crop and mask the DEM to the border extent
clipped_DEM <- crop(USGS_DEM, border) |> mask(border)

# Load all topographic rasters
topo_files <- list.files("Data/all rasters/", full.names = TRUE)
topo_rasters <- lapply(topo_files, rast)

# Function to align rasters (clip first, then resample to 1m)
align_raster <- function(r, template, border) {
  # Reproject raster
  if (crs(r) != crs(template)) {
    r <- project(r, crs(template), method = "bilinear")
  }
  # Resample to match the clipped DEM's resolution
  r <- resample(r, template, method = "bilinear")
  # Crop and mask to the border FIRST
  r <- crop(r, border) |> mask(border)

  return(r)
}

# Align all rasters
aligned_rasters <- lapply(topo_rasters, align_raster, template = clipped_DEM, border = border)

# Stack aligned rasters
clipped_stack <- rast(aligned_rasters)

# Summary check
summary(clipped_stack)


```

```{r Bare Soil}
#planet bare soil imagery: 
bare_soil <- rast("Data/Planet/Bare Soil Imagery/Apr 2022/20220429_152053_57_245c_3B_udm2_clip_projected.tif")
#bare_soil_wgs84 <- project(bare_soil, "EPSG:4326", res = 1, method = "bilinear") #doesn't work
bare_soil_utm <- project(bare_soil,clipped_stack)
#bare_soil_res1 <- terra::resample(bare_soil_utm, clipped_stack)
bare_soil_res1 <- project(bare_soil,clipped_stack)


# SURFACE REFLECTANCE:

reflectanceCoefficients <- c(2.028e-05, 1.959e-05, 2.094e-05, 2.124e-05,  # Bands 1-4 
                             2.018e-05, 1.511e-05, 1.372e-05, 1.092e-05)  # Bands 5-8 

# Apply band-specific reflectance coefficients (not sure if Planet already corrected for SR)
surface_reflectance <- bare_soil_res1
for (i in 1:nlyr(bare_soil_res1)) { #for every band, multiply value by its band coefficient
surface_reflectance[[i]] <- bare_soil_res1[[i]] * reflectanceCoefficients[i]
}

# Save new SR
writeRaster(surface_reflectance, "Output/Bare_soil/SR.tif", overwrite = TRUE)

  # Plot random band:
plot(surface_reflectance[[7]], main = "NIR1 Surface Reflectance")
plot(bare_soil_res1[[7]])

SR_names<-array(dim = nlyr(surface_reflectance))

for (i in 1:nlyr(surface_reflectance)){
  SR_names[i]<-paste0("bare_soil_SR_band_",i)
}

names(surface_reflectance)<-SR_names

```

```{r NDVI}

# Veg data: Planet 
Vegstack <- rast("Data/Planet/Veg Imagery/Sept 2022/20220921_152148_44_2465_3B_AnalyticMS_SR_8b_clip.tif")

Vegstack_utm <- project(bare_soil,clipped_stack)


#NDVI:


NIR <- Vegstack_utm[[8]]  # NIR band
Red <- Vegstack_utm[[6]]  # Red band

# formula
NDVI <- (NIR - Red) / (NIR + Red)

names(NDVI)<- "NDVI"

# Plot NDVI
plot(NDVI)


#SAVI: 


L <- 0.5  # adjustable

# formula
SAVI <- ((NIR - Red) / (NIR + Red + L)) * (1 + L)

names(SAVI)<- "SAVI"


# Plot SAVI
plot(SAVI)

```

```{r 1m rasters, eval = FALSE}

#Visualizations via OpenTopography:
aspect <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_aspect.tif")
#aspect_wgs84 <- project(aspect, "EPSG:4326",res = 1, method = "bilinear")
clipped_aspect <- mask(aspect, vect(border))
plot(clipped_aspect)

color_relief <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_color-relief.tif")
color_relief_wgs84 <- project(color_relief, "EPSG:4326",res = 1, method = "bilinear")
clipped_color_relief_wgs84 <- mask(color_relief_wgs84, vect(border))

color_hillshade <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_hillshade-color.tif")
color_hillshade_wgs84 <- project(color_hillshade, "EPSG:4326",res = 1, method = "bilinear")
clipped_color_hillshade_wgs84 <- mask(color_hillshade_wgs84, vect(border))

hillshade <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_hillshade.tif")
hillshade_wgs84 <- project(hillshade, "EPSG:4326",res = 1, method = "bilinear")
clipped_hillshade_wgs84 <- mask(hillshade_wgs84, vect(border))

roughness <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_roughness.tif")
roughness_wgs84 <- project(roughness, "EPSG:4326",res = 1, method = "bilinear")
clipped_roughness_wgs84 <- mask(roughness_wgs84, vect(border))

slope <- rast("Data/USGS DEM/Visualization Products/viz.USGS1m_slope.tif")
slope_wgs84 <- project(slope, "EPSG:4326",res = 1, method = "bilinear")
clipped_slope_wgs84 <- mask(slope_wgs84, vect(border))


#SAGA visualizations:
slope_height <-rast("Data/USGS DEM/SAGA/Slope Height.sg-grd-z")
slope_height_wgs84 <- project(slope_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_slope_height_wgs84 <- mask(slope_height_wgs84, vect(border))

valley_depth <-rast("Data/USGS DEM/SAGA/Valley Depth.sg-grd-z")
valley_depth_wgs84 <- project(valley_depth, "EPSG:4326",res = 1, method = "bilinear")
clipped_valley_depth_wgs84 <- mask(valley_depth_wgs84, vect(border))

norm_height <-rast("Data/USGS DEM/SAGA/Normalized Height.sg-grd-z")
norm_height_wgs84 <- project(norm_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_norm_height_wgs84 <- mask(norm_height_wgs84, vect(border))

std_height <-rast("Data/USGS DEM/SAGA/Standardized Height.sg-grd-z")
std_height_wgs84 <- project(std_height, "EPSG:4326",res = 1, method = "bilinear")
clipped_std_height_wgs84 <- mask(std_height_wgs84, vect(border))

mid_slope_pos <-rast("Data/USGS DEM/SAGA/Mid-Slope Positon.sg-grd-z")
mid_slope_pos_wgs84 <- project(mid_slope_pos, "EPSG:4326",res = 1, method = "bilinear")
clipped_mid_slope_pos_wgs84 <- mask(mid_slope_pos_wgs84, vect(border))

topo_pos_index <-rast("Data/USGS DEM/SAGA/Topographic Position Index.sg-grd-z")
topo_pos_index_wgs84 <- project(topo_pos_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_topo_pos_index_wgs84 <- mask(topo_pos_index_wgs84, vect(border))

topo_wet_index <-rast("Data/USGS DEM/SAGA/Topographic Wetness Index.sg-grd-z")
topo_wet_index_wgs84 <- project(topo_wet_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_topo_wet_index_wgs84 <- mask(topo_wet_index_wgs84, vect(border))

terr_rugged_index <-rast("Data/USGS DEM/SAGA/Terrain Ruggedness Index (TRI).sg-grd-z")
terr_rugged_index_wgs84 <- project(terr_rugged_index, "EPSG:4326",res = 1, method = "bilinear")
clipped_terr_rugged_index_wgs84 <- mask(terr_rugged_index_wgs84, vect(border))

mrvbf <-rast("Data/USGS DEM/SAGA/MRVBF.sg-grd-z")
mrvbf_wgs84 <- project(mrvbf, "EPSG:4326",res = 1, method = "bilinear")
clipped_mrvbf_wgs84 <- mask(mrvbf_wgs84, vect(border))

mrrtf <-rast("Data/USGS DEM/SAGA/MRRTF.sg-grd-z")
mrrtf_wgs84 <- project(mrrtf, "EPSG:4326",res = 1, method = "bilinear")
clipped_mrrtf_wgs84 <- mask(mrrtf_wgs84, vect(border))


```




##Data Wrangling
```{r}
covariates <- c(surface_reflectance, clipped_stack, NDVI, SAVI)

names(covariates) <- make.names(names(covariates))
```








```{r vect}


# vect the sample data
soil_points_vect <- vect(soil_points)

```






```{r Organizing}
# Extract raster values at soil sample points
soil_points_all <- terra::extract(covariates, soil_points_vect, bind = T,xy = T)


#convert to df
soils_df <- as.data.frame(soil_points_all)


# Select only the desired columns
soil_df_cols <- soils_df[, c('LBC.1', 'LBCeq', 'pH.2', 'Ca', 'K', 'Mg', 'Mn', 'P', 'Zn')]


#exclude non essential data:
soils_df_wrang <- soils_df[ ,-(1:9)]


```



##Correlation Matrix
```{r Cor() }
# Compute correlation matrix
cor_matrix <- cor(soils_df_wrang, use = "pairwise.complete.obs", method = "spearman")

```

```{r plotting CM }
#formatting:
ggcorrplot(cor_matrix, type = "lower", 
           lab = TRUE, show.legend = TRUE, 
           tl.cex = 4, # Adjust text size
           lab_size = 2, # Adjust correlation label size
           tl.srt = 45) # Rotate axis labels

ggcorrplot(cor_matrix, type = "lower", 
           lab = TRUE, show.legend = TRUE, 
           tl.cex = 4, # Adjust text size
           lab_size = 2, # Adjust correlation label size
           tl.srt = 45,           
           hc.order = TRUE, # Cluster similar variables together
           insig = "blank", # Hide insignificant correlations
           p.mat = cor_pmat(soils_df_wrang)
           ) # Rotate axis labels


# col name of soil properties
soil_vars <- colnames(soil_df_cols)
# topo name list
topo_vars <- setdiff(colnames(soils_df_wrang), soil_vars)

# Compute correlation matrix only between soil properties and topo rasters
cor_matrix_soil_topo <- cor(soils_df_wrang[, soil_vars], soils_df_wrang[, topo_vars], 
                            use = "pairwise.complete.obs", method = "spearman")

# Visualize
ggcorrplot(cor_matrix_soil_topo, lab = TRUE, show.legend = TRUE, 
           tl.cex = 5, lab_size = 2, tl.srt = 45, method = "circle")




#scatterplot



ggsave("../Mapping/Output/Correlation_Matrix_1.png")

```







#Stack Results
```{r Stack data }

cor_matrix_soil_topo_t <- t(cor_matrix_soil_topo)

cor_sort<-list()

for (i in 1:ncol(cor_matrix_soil_topo_t)) {
  col_sort<-sort(abs(cor_matrix_soil_topo_t[,i]),decreasing = T)
  cor_sort[[i]]<-col_sort
}

cor_sort_wrang<-setNames(cor_sort,colnames(cor_matrix_soil_topo_t))



```


#RF
```{r DSM method}
library(caret)


set.seed(10)

LBC_df <- soils_df_wrang %>%
  dplyr::select(-c('LBCeq', 'pH.2', 'Ca', 'K', 'Mg', 'Mn', 'P', 'Zn'))

LBC_index_train <- caret::createDataPartition(LBC_df$LBC.1, p = .8, list = F)

LBC_df_train <- LBC_df[LBC_index_train,]
LBC_df_test <- LBC_df[-LBC_index_train,]

trainControl <- trainControl(method = "cv", number = 5)

LBC_rf <- train(LBC.1 ~ ., data = LBC_df_train, method = "rf", trControl = trainControl)

print(LBC_rf)

LBC_predict <- terra::predict(covariates, LBC_rf, na.rm=TRUE)

plot(LBC_predict)

LBCeq_df <- soils_df_wrang %>%
  dplyr::select(-c('LBC.1', 'pH.2', 'Ca', 'K', 'Mg', 'Mn', 'P', 'Zn'))

LBC_index_train <- caret::createDataPartition(LBC_df$LBC.1, p = .8, list = F)

LBC_df_train <- LBC_df[LBC_index_train,]
LBC_df_test <- LBC_df[-LBC_index_train,]

trainControl <- trainControl(method = "cv", number = 5)

LBC_rf <- train(LBC.1 ~ ., data = LBC_df_train, method = "rf", trControl = trainControl)

print(LBC_rf)

LBC_predict <- terra::predict(covariates, LBC_rf, na.rm=TRUE)

plot(LBC_predict)
```


#Kriging
```{r Kriging}
grid<-as.points(covariates)

plot(grid)

grid_sf <- st_as_sf(grid)

grid_sp <- as_Spatial(grid_sf)

soil_points_sf <- st_as_sf(soil_points_all)

soil_points_sp <- as_Spatial(soil_points_sf)

LBC_var<-variogram(LBC.1~1,data = soil_points_sp)

plot(LBC_var)

LBC_varfit<-fit.variogram(LBC_var, model = vgm("Sph"))

plot(LBC_var, LBC_varfit)

LBC_kriged<-krige(LBC.1~1,soil_points_sp,grid_sp,model = LBC_varfit)

LBC_kriged_sf<-st_as_sf(LBC_kriged)

LBC_kriged_spat<-vect(LBC_kriged_sf)

LBC_kriged_raster<-rasterize(LBC_kriged_spat,covariates, field="var1.pred")

plot(LBC_kriged_raster)

P_var<-variogram(P~1,data = soil_points_sp)

plot(P_var)

P_varfit<-fit.variogram(P_var, model = vgm("Sph"))

plot(P_var, P_varfit)

P_kriged<-krige(P~1,soil_points_sp,grid_sp,model = P_varfit)

P_kriged_sf<-st_as_sf(P_kriged)

P_kriged_spat<-vect(P_kriged_sf)

P_kriged_raster<-rasterize(P_kriged_spat,covariates, field="var1.pred")

plot(P_kriged_raster)

```
























```{r stack}

```


#Classification
```{r Classification}


#K
classify_K <- function(K) {
  case_when(
    K <= 60  ~ "Low K (0-60 lbs/A)",    
    K <= 150 ~ "Medium K (61-150 lbs/A)",  
    K <= 250 ~ "High K (151-250 lbs/A)",  
    K > 250  ~ "Very High K (250+ lbs/A)"
  )
}


#P
classify_P <- function(P) {
  case_when(
    P <= 30  ~ "Low P (0-30 lbs/A)",
    P <= 60  ~ "Medium P (31-60 lbs/A)",
    P <= 100 ~ "High P (61-100 lbs/A)",
    P > 100  ~ "Very High P (100+ lbs/A)"
  )
}
library(tidyterra)
P_kriged_raster %>%
  mutate(P_class = case_when(
    P <= 30  ~ "Low P (0-30 lbs/A)",
    P <= 60  ~ "Medium P (31-60 lbs/A)",
    P <= 100 ~ "High P (61-100 lbs/A)",
    P > 100  ~ "Very High P (100+ lbs/A)"))


#pH
classify_pH <- function(pH, LBC) {
  lime_table <- read.csv("lime_requirements.csv")  # Make sure this table is structured properly
  required_lime <- lime_table %>%
    filter(pH == round(pH, 1)) %>%
    select(as.character(LBC)) %>%
    pull()

  return(required_lime)
}


#Mg
classify_Mg <- function(Mg) {
  case_when(
    Mg <= 30  ~ "Low Mg - Apply Dolomitic Lime",
    Mg <= 60  ~ "Medium Mg - No Extra Mg Needed",
    Mg > 60   ~ "High Mg - No Supplement Needed"
  )
}
#Zn
classify_Zn <- function(Zn) {
  if (Zn < 3) {
    return("Apply 3 lbs Zn/Acre")
  } else {
    return("No Zn Needed")
  }
}

```
#Condense
```{r Flatten Stacks}

```
#Clean Maps
```{r Clean Up Maps}

```

```{r Compare Maps}

```





```{r pH: extra stuff}

# Convert sf to sp
soil_points_sp <- as(soil_points, "Spatial")

# Compute the empirical variogram for pH
emp_variogram <- variogram(soil_points_sp$pH.2 ~ 1, soil_points_sp)

# Fit a model to the variogram
var_model <- fit.variogram(emp_variogram, vgm(c("Sph", "Exp", "Gau")))

# Plot the variogram
plot(emp_variogram, model = var_model)

```



